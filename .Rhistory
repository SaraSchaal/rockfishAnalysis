par(mfrow = c(1,2))
plot(b.slopes[ ,1]~b.unique_Days_num, type = "l",
ylim = c(min(c.slopes)-0.05, max(c.slopes)+0.05),
lwd = 2, bty = "l", ylab= "Activity vs Temperature Regression Slope",
xlab = "Day of Experiment")
points(b.slopes[ ,3]~b.unique_Days_num, type = "l", col = "grey")
points(b.slopes[ ,4]~b.unique_Days_num, type = "l", col = "grey")
abline(0,0, lty = 2)
legend("topleft", legend = c("BY Complex", "CQ complex"), col = c("black", "orange"), lwd = 2)
plot(c.slopes[ ,1]~c.unique_Days_num, type = "l", lwd = 2, col = "orange",
bty = "l", ylim = c(min(c.slopes)-0.05, max(c.slopes)+0.05),
ylab = NA, xlab = "Day of Experiment")
points(c.slopes[ ,3]~c.unique_Days_num, type = "l", col = "grey")
points(c.slopes[ ,4]~c.unique_Days_num, type = "l", col = "grey")
abline(0,0, lty = 2)
par(mfrow = c(1,2))
plot(b.slopes[ ,1]~b.unique_Days_num, type = "l",
ylim = c(min(c.slopes)-0.05, max(c.slopes)+0.05),
lwd = 2, bty = "l", ylab= "Activity vs Temperature Regression Slope",
xlab = "Day of Experiment")
points(b.slopes[ ,3]~b.unique_Days_num, type = "l", col = "grey")
points(b.slopes[ ,4]~b.unique_Days_num, type = "l", col = "grey")
abline(0,0, lty = 2)
legend("topleft", legend = c("BY Complex", "CQ complex"), col = c("black", "orange"), lwd = 2)
mtext(text = "A", side = 3, adj = 0.01, padj = 0.01)
plot(c.slopes[ ,1]~c.unique_Days_num, type = "l", lwd = 2, col = "orange",
bty = "l", ylim = c(min(c.slopes)-0.05, max(c.slopes)+0.05),
ylab = NA, xlab = "Day of Experiment")
points(c.slopes[ ,3]~c.unique_Days_num, type = "l", col = "grey")
points(c.slopes[ ,4]~c.unique_Days_num, type = "l", col = "grey")
abline(0,0, lty = 2)
mtext(text = "B", side = 3, adj = 0.01, padj = 0.01)
par(mfrow = c(1,2))
plot(b.slopes[ ,1]~b.unique_Days_num, type = "l",
ylim = c(min(c.slopes)-0.05, max(c.slopes)+0.05),
lwd = 2, bty = "l", ylab= "Activity vs Temperature Regression Slope",
xlab = "Day of Experiment")
points(b.slopes[ ,3]~b.unique_Days_num, type = "l", col = "grey")
points(b.slopes[ ,4]~b.unique_Days_num, type = "l", col = "grey")
abline(0,0, lty = 2)
legend("topleft", legend = c("BY Complex", "CQ complex"), col = c("black", "orange"), lwd = 2)
mtext(text = "A", side = 3, adj = 0.01, padj = 0.01)
plot(c.slopes[ ,1]~c.unique_Days_num, type = "l", lwd = 2, col = "orange",
bty = "l", ylim = c(min(c.slopes)-0.05, max(c.slopes)+0.05),
ylab = NA, xlab = "Day of Experiment")
points(c.slopes[ ,3]~c.unique_Days_num, type = "l", col = "grey")
points(c.slopes[ ,4]~c.unique_Days_num, type = "l", col = "grey")
abline(0,0, lty = 2)
mtext(text = "B", side = 3, adj = 0.01, padj = 0.01)
mc <- lsmeans(mod1, pairwise ~ factor, adjust = "Tukey")
mc <- lsmeans(mod1, Treatment_Temperature ~ Species2, adjust = "Tukey")
mc <- lsmeans(mod1, Treatment_Temperature ~ Species2, data = mort.data, adjust = "Tukey")
?lsmeans
mc <- lsmeans(mod1, ~ Species2, data = mort.data, adjust = "Tukey")
mod1 <- glm(cbind(Days_Survived, DaysDead)~Treatment_Temperature*Species2,
family = quasibinomial(link = "logit"),
data = mort.data)
mort.data <- read.csv("/Users/saraschaal/Documents/Northeastern/LotterhosLab/Research/Field Work/2015/TPC_Experiment/Analysis/data/Mortality.csv")
mort.data$Treatment_Temperature <- round(mort.data$Treatment_Temperature, digits = 1)
mort.data <- mort.data[!mort.data$Species == "" & !mort.data$Species == "Hybrid",]
mort.data$DaysDead <- 14-mort.data$Days_Survived
mort.data$PropDaysSurv <- mort.data$Days_Survived/14
mort.data$Species2 <- NA
for(i in 1:nrow(mort.data)){
if(mort.data$Species[i] == "Black" | mort.data$Species[i] == "Yellowtail"){
mort.data$Species2[i] <- "BY"
} else {
mort.data$Species2[i] <- mort.data$Species[i]
}
}
mort.data$Species2 <- as.factor(mort.data$Species2)
levels(mort.data$Species2) <- c("Copper", "Quillback", "BY")
log.mod.all.prop <- glm(cbind(Days_Survived, DaysDead)~Treatment_Temperature*Species,
family = binomial(link = 'logit'), data = mort.data)
summary(log.mod.all.prop)
summary(aov(log.mod.all.prop))
drop1(log.mod.all.prop)
log.mod.all.prop <- glm(cbind(Days_Survived, DaysDead)~Treatment_Temperature*Species,
family = binomial(link = 'logit'), data = mort.data)
log.mod.all.prop3 <- glm(cbind(Days_Survived, DaysDead)~Treatment_Temperature*Species2,
family = binomial(link = 'logit'), data = mort.data)
summary(log.mod.all.prop3)
summary(aov(log.mod.all.prop3))
mod1 <- glm(cbind(Days_Survived, DaysDead)~Treatment_Temperature*Species2,
family = quasibinomial(link = "logit"),
data = mort.data)
anova(mod1)
Anova(mod1)
mc <- lsmeans(mod1, ~ Species2, data = mort.data, adjust = "Tukey")
mc
mc
mc <- lsmeans(mod1, ~ Species2, adjust = "Tukey")
mc
Anova(mod1)
mc
library(multcompView)
cld(mc, alpha = 0.05, Letters = letters, adjust = "tukey")
### Black Rockfish ###
# create empty data frames for mean bucket activity values
Mean.Activity <- matrix(NA, nrow(unique(black.act[c("Date", "AM_PM", "Bucket")])),4)
bucket.act.average <- unique(black.act[c("Date", "AM_PM", "Bucket", "Temperature")])
complete.act.data <- cbind(bucket.act.average, Mean.Activity)
colnames(complete.act.data) <- c("Date", "AM_PM", "Bucket", "Temperature",
"mean.julia", "mean.sandi", "mean.both", "FishAlive")
# initialize the vectors that will be used in the forloop ** NOTE data in these
# vectors is written over in each loop.. they are TEMPORARY vectors **
bucket.act.julia <- NULL
bucket.act.sandi <- NULL
bucket.act.both <- NULL
# initialize the counter for stepping through the output matrix
j <- 1
# For loop to step through data frame to get activity averages
for(i in 1:nrow(black.act)){
# looping through majority of data to grab all those rows that are not the last row
# but are all those that equal the same bucket from the same day and getting
# activity averages
if(i != nrow(black.act) && i == 1 ||
black.act$Bucket[i] == black.act$Bucket[i-1] && i != nrow(black.act)){
bucket.act.julia <- c(bucket.act.julia, black.act$Act_Mean_Julia[i])
bucket.act.sandi <- c(bucket.act.sandi, black.act$Act_Mean_Sandi[i])
bucket.act.both <- c(bucket.act.both, black.act$Act_Mean_Julia[i], black.act$Act_Mean_Sandi[i])
# special case for last row
} else {
if(i == nrow(black.act)){
# Remove any NAs before taking mean for a bucket at a timepoint
bucket.act.both.noNA <- bucket.act.both[!is.na(bucket.act.both)]
bucket.act.julia.noNA <- bucket.act.julia[!is.na(bucket.act.julia)]
bucket.act.sandi.noNA <- bucket.act.sandi[!is.na(bucket.act.sandi)]
complete.act.data$mean.julia[j] <- sum(bucket.act.julia.noNA)/length(bucket.act.julia.noNA)
complete.act.data$mean.sandi[j] <- sum(bucket.act.sandi.noNA)/length(bucket.act.sandi.noNA)
complete.act.data$mean.both[j] <- sum(bucket.act.both.noNA)/length(bucket.act.both.noNA)
complete.act.data$FishAlive[j] <- length(bucket.act.sandi.noNA)
j <- j + 1
} else {
# Remove any NAs before taking mean for a bucket at a timepoint
bucket.act.both.noNA <- bucket.act.both[!is.na(bucket.act.both)]
bucket.act.julia.noNA <- bucket.act.julia[!is.na(bucket.act.julia)]
bucket.act.sandi.noNA <- bucket.act.sandi[!is.na(bucket.act.sandi)]
# Take mean of that bucket for that day and insert into complete.data dataframe
complete.act.data$mean.julia[j] <- sum(bucket.act.julia.noNA)/length(bucket.act.julia.noNA)
complete.act.data$mean.sandi[j] <- sum(bucket.act.sandi.noNA)/length(bucket.act.sandi.noNA)
complete.act.data$mean.both[j] <- sum(bucket.act.both.noNA)/length(bucket.act.both.noNA)
complete.act.data$FishAlive[j] <- length(bucket.act.sandi.noNA)
bucket.act.julia <- black.act$Act_Mean_Julia[i]
bucket.act.sandi <- black.act$Act_Mean_Sandi[i]
bucket.act.both <- c(black.act$Act_Mean_Julia[i], black.act$Act_Mean_Sandi[i])
# counter to step through inputting data into the complete.data dataframe
j <- j + 1
} # close else
} # close if else
} # close for loop
### Copper Rockfish ###
# create empty data frames for mean bucket activity values
Mean.Activity.cp <- matrix(NA, nrow(unique(copper.act[c("Date", "AM_PM", "Bucket")])),4)
bucket.act.average.cp <- unique(copper.act[c("Date", "AM_PM", "Bucket", "Temperature")])
complete.act.data.cp <- cbind(bucket.act.average.cp, Mean.Activity.cp)
colnames(complete.act.data.cp) <- c("Date", "AM_PM", "Bucket", "Temperature",
"mean.julia", "mean.sandi", "mean.both", "FishAlive")
# initialize the vectors that will be used in the for loop ** NOTE data in these vectors is written
# over in each loop.. they are TEMPORARY vectors **
bucket.act.julia.cp <- NULL
bucket.act.sandi.cp <- NULL
bucket.act.both.cp <- NULL
bucket.act.both.noNA.cp <- NULL
bucket.act.julia.noNA.cp <- NULL
bucket.act.sandi.noNA.cp <- NULL
# initialize the counter for stepping through the output matrix
j <- 1
i <- 1
# For loop to step through data frame to get activity averages
for(i in 1:nrow(copper.act)){
# looping through majority of data to grab all those rows that are not the last row
# but are all those that equal the same bucket from the same day and getting activity averages
if(i != nrow(copper.act) && i == 1 ||
copper.act$Bucket[i] == copper.act$Bucket[i-1] && i != nrow(copper.act)){
bucket.act.julia.cp <- c(bucket.act.julia.cp, copper.act$Act_Mean_Julia[i])
bucket.act.sandi.cp <- c(bucket.act.sandi.cp, copper.act$Act_Mean_Sandi[i])
bucket.act.both.cp <- c(bucket.act.both.cp, copper.act$Act_Mean_Julia[i], copper.act$Act_Mean_Sandi[i])
# special case for last row
} else {
if(i == nrow(copper.act)){
# Remove any NAs before taking mean for a bucket at a timepoint
bucket.act.both.noNA.cp <- bucket.act.both.cp[!is.na(bucket.act.both.cp)]
bucket.act.julia.noNA.cp <- bucket.act.julia.cp[!is.na(bucket.act.julia.cp)]
bucket.act.sandi.noNA.cp <- bucket.act.sandi.cp[!is.na(bucket.act.sandi.cp)]
complete.act.data.cp$mean.julia[j] <- sum(bucket.act.julia.noNA.cp)/length(bucket.act.julia.noNA.cp)
complete.act.data.cp$mean.sandi[j] <- sum(bucket.act.sandi.noNA.cp)/length(bucket.act.sandi.noNA.cp)
complete.act.data.cp$mean.both[j] <- sum(bucket.act.both.noNA.cp)/length(bucket.act.both.noNA.cp)
complete.act.data.cp$FishAlive[j] <- length(bucket.act.sandi.noNA.cp)
j <- j + 1
} else {
# Remove any NAs before taking mean for a bucket at a timepoint
bucket.act.both.noNA.cp <- bucket.act.both.cp[!is.na(bucket.act.both.cp)]
bucket.act.julia.noNA.cp <- bucket.act.julia.cp[!is.na(bucket.act.julia.cp)]
bucket.act.sandi.noNA.cp <- bucket.act.sandi.cp[!is.na(bucket.act.sandi.cp)]
# Take mean of that bucket for that day and insert into complete.data dataframe
complete.act.data.cp$mean.julia[j] <- sum(bucket.act.julia.noNA.cp)/length(bucket.act.julia.noNA.cp)
complete.act.data.cp$mean.sandi[j] <- sum(bucket.act.sandi.noNA.cp)/length(bucket.act.sandi.noNA.cp)
complete.act.data.cp$mean.both[j] <- sum(bucket.act.both.noNA.cp)/length(bucket.act.both.noNA.cp)
complete.act.data.cp$FishAlive[j] <- length(bucket.act.sandi.noNA.cp)
bucket.act.julia.cp <- copper.act$Act_Mean_Julia[i]
bucket.act.sandi.cp <- copper.act$Act_Mean_Sandi[i]
bucket.act.both.cp <- c(copper.act$Act_Mean_Julia[i], copper.act$Act_Mean_Sandi[i])
# counter to step through inputting data into the complete.data dataframe
j <- j + 1
} # close else
} # close if else
} # close for loop
head(complete.act.data)
hist(complete.act.data$mean.both)
hist(complete.act.data.cp$mean.both)
hist(log10(complete.act.data.cp$mean.both))
hist(log10(complete.act.data$mean.both))
TukeyHSD(mod1)
mod2 <- Anova(mod1)
TukeyHSD(mod2)
mod2 <- anova(mod1)
TukeyHSD(mod2)
log.mod.all.prop4 <- glm(cbind(Days_Survived, DaysDead)~Treatment_Temperature + Species2,
family = binomial(link = 'logit'), data = mort.data)
cld(mc, alpha = 0.05, Letters = letters, adjust = "tukey")
plot(mod1)
par(mfrow = c(1,1))
AICc(log.mod.all.prop3, mx)
??AICc
library(AICcmodavg)
AICc(log.mod.all.prop3, mx)
mx <- glm(cbind(Days_Survived, DaysDead)~Treatment_Temperature+Species2,
family = binomial(link = 'logit'), data = mort.data)
AICc(log.mod.all.prop3, mx)
AIC(log.mod.all.prop3, mx)
AIC(log.mod.all.prop3)
AICc(log.mod.all.prop3)
AICc(mx)
plot(log.mod.all.prop3)
plot(all.m3)
summary(aov(all.m2))
summary(all.m2)
plot(all.m2)
summary(aov(cop.act.m1)) # why isn't the interaction significant??
species.act.m1 <- lm(full.act.data$mean.both~ full.act.data$Temperature*as.numeric(full.act.data$DateTimePOS)*full.act.data$species)
cop.act.m1 <- lm(complete.act.data.cp$mean.both~complete.act.data.cp$Temperature +
as.numeric(complete.act.data.cp$DateTimePOS) +
complete.act.data.cp$Temperature*as.numeric(complete.act.data.cp$DateTimePOS))
library(plyr)
#Inspect data elements
str(complete.act.data)
# Construct AM/PM to be times
complete.act.data$AM_PMTime <- complete.act.data$AM_PM
complete.act.data$AM_PMTime <- revalue(complete.act.data$AM_PMTime,
c("AM" = "09:00:00", "PM" = "18:00:00"))
complete.act.data.cp$AM_PMTime <- complete.act.data.cp$AM_PM
complete.act.data.cp$AM_PMTime <- revalue(complete.act.data.cp$AM_PMTime,
c("AM" = "09:00:00", "PM" = "18:00:00"))
# Create POSIX
# black
complete.act.data$DateTimePOS <- as.POSIXlt(paste(as.Date(as.character(complete.act.data$Date),
format = ("%Y%m%d")),
as.character(complete.act.data$AM_PMTime)))
# copper
complete.act.data.cp$DateTimePOS <- as.POSIXlt(paste(as.Date(as.character(complete.act.data.cp$Date),
format = ("%Y%m%d")),
as.character(complete.act.data.cp$AM_PMTime)))
blk.act.m1 <- lm(complete.act.data$mean.both~complete.act.data$Temperature +
as.numeric(complete.act.data$DateTimePOS) +
complete.act.data$Temperature*as.numeric(complete.act.data$DateTimePOS))
summary(aov(blk.act.m1))
summary(aov(blk.act.m1))
summary(blk.act.m1)
mod1 <- glm(cbind(Days_Survived, DaysDead)~Treatment_Temperature*Species2,
family = quasibinomial(link = "logit"),
data = mort.data)
anova(mod1)
summary(mod1)
log.mod.all.prop3 <- glm(cbind(Days_Survived, DaysDead)~Treatment_Temperature*Species2,
family = binomial(link = 'logit'), data = mort.data)
summary(log.mod.all.prop3)
summary(mod1)
drop1(mod1)
mod2 <- glm(cbind(Days_Survived, DaysDead)~Treatment_Temperature + Species2,
family = quasibinomial(link = "logit"),
data = mort.data)
lrtest(mod1, mod2)
library(car)
lrtest(mod1, mod2)
library(epicalc)
install.packages(epicalc)
anova(mod1, mod2)
anova(mod1)
Anova(mod1)
summary(mod1)
mc <- lsmeans(mod1, ~ Species2, adjust = "Tukey")
mc
anova(mod1)
Anova(mod1)
mc
mc <- lsmeans(mod1, ~ Species2, adjust = "Tukey")
mc
cld(mc, alpha = 0.05, Letters = letters, adjust = "tukey")
mc <- lsmeans(mod1, ~ Species2, adjust = "Tukey")
mc
summary(mc)
summary(mod1)
drop1(mod1)
lrtest(mod1, mod2)
anova(mod1, mod2)
aov(mod1, mod2)
anova(mod1, mod2, test = "lr")
anova(mod1, mod2, test = "LRT")
blk.act.m1 <- lm(complete.act.data$mean.both~complete.act.data$Temperature +
as.numeric(complete.act.data$DateTimePOS) +
complete.act.data$Temperature*as.numeric(complete.act.data$DateTimePOS))
summary(aov(blk.act.m1))
summary(blk.act.m1)
drop1(blk.act.m1)
species.act.m1 <- lm(full.act.data$mean.both~ full.act.data$Temperature*as.numeric(full.act.data$DateTimePOS)*full.act.data$species)
full.act.data <- rbind(complete.act.data.sp,complete.act.data.cp.sp)
species <- rep("Black", 259)
complete.act.data.sp <- cbind(complete.act.data, species)
species.cp <- rep("Copper", 271)
complete.act.data.cp.sp <- cbind(complete.act.data.cp, species.cp)
colnames(complete.act.data.cp.sp)[13] <- "species"
full.act.data <- rbind(complete.act.data.sp,complete.act.data.cp.sp)
summary(all.m3)
summary(aov(all.m2))
summary(all.m2)
anova(all.m2)
Anova(all.m2)
drop1(all.m2) # Shows a significant affect of temp on growth in Quillback but N = 6
anova(all.m2, all.m3, test = "LRT")
log.mod.all.prop3 <- glm(cbind(Days_Survived, DaysDead)~Treatment_Temperature*Species2,
family = binomial(link = 'logit'), data = mort.data)
#### Read In Data ####
mort.data <- read.csv("/Users/saraschaal/Documents/Northeastern/LotterhosLab/Research/Field Work/2015/TPC_Experiment/Analysis/data/Mortality.csv")
mort.data$Treatment_Temperature <- round(mort.data$Treatment_Temperature, digits = 1)
#remove those that could not be identified to the species level
mort.data <- mort.data[!mort.data$Species == "" & !mort.data$Species == "Hybrid",]
# calculate days dead
mort.data$DaysDead <- 14-mort.data$Days_Survived
mort.data$PropDaysSurv <- mort.data$Days_Survived/14
#### Combine Black and Yellowtail Data ####
# Make a new species column that combines black and yellowtail rockfish
mort.data$Species2 <- NA
# Find all rows where species is either black or yellowtail and add BY to new species column
for(i in 1:nrow(mort.data)){
if(mort.data$Species[i] == "Black" | mort.data$Species[i] == "Yellowtail"){
mort.data$Species2[i] <- "BY"
} else {
mort.data$Species2[i] <- mort.data$Species[i]
}
}
# Factor new species column
mort.data$Species2 <- as.factor(mort.data$Species2)
# Set levels to meaningful names
levels(mort.data$Species2) <- c("Copper", "Quillback", "BY")
log.mod.all.prop <- glm(cbind(Days_Survived, DaysDead)~Treatment_Temperature*Species,
family = binomial(link = 'logit'), data = mort.data)
summary(log.mod.all.prop)
summary(aov(log.mod.all.prop))
benguela <- read.csv("http://faraway.neu.edu/data/assn3_benguela.csv")
benguela <- read.csv("http://faraway.neu.edu/data/assn3_benguela.csv")
str(benguela)
california <- read.csv("http://faraway.neu.edu/data/assn3_california.csv")
canary <- read.csv("http://faraway.neu.edu/data/assn3_canary.csv")
humboldt <- read.csv("http://faraway.neu.edu/data/assn3_humboldt.csv")
period.benguela <- ifelse(benguela$year >= 2024,"After","Before")
period.california <- ifelse(california$year >= 2024, "After","Before")
period.canary <- ifelse(canary$year >= 2024, "After","Before")
period.humboldt <- ifelse(humboldt$year >= 2024,"After","Before")
benguela.multimodel.mean <- rowMeans(benguela[,1:22], na.rm=FALSE)
benguela.multimodel.mean
benguela
anova(mod1, mod2, test = "LRT")
rm(list = ls())
mort.data <- read.csv("/Users/saraschaal/Documents/Northeastern/LotterhosLab/Research/Field Work/2015/TPC_Experiment/Analysis/data/Mortality.csv")
mort.data$Treatment_Temperature <- round(mort.data$Treatment_Temperature, digits = 1)
mort.data <- mort.data[!mort.data$Species == "" & !mort.data$Species == "Hybrid",]
mort.data$DaysDead <- 14-mort.data$Days_Survived
mort.data$PropDaysSurv <- mort.data$Days_Survived/14
mort.data$Species2 <- NA
for(i in 1:nrow(mort.data)){
if(mort.data$Species[i] == "Black" | mort.data$Species[i] == "Yellowtail"){
mort.data$Species2[i] <- "BY"
} else {
mort.data$Species2[i] <- mort.data$Species[i]
}
}
mort.data$Species2 <- as.factor(mort.data$Species2)
levels(mort.data$Species2) <- c("Copper", "Quillback", "BY")
library(AICcmodavg)
log.mod.all.prop <- glm(cbind(Days_Survived, DaysDead)~Treatment_Temperature*Species,
family = binomial(link = 'logit'), data = mort.data)
summary(log.mod.all.prop)
summary(aov(log.mod.all.prop))
drop1(log.mod.all.prop)
log.mod.all.prop3 <- glm(cbind(Days_Survived, DaysDead)~Treatment_Temperature*Species2,
family = binomial(link = 'logit'), data = mort.data)
summary(log.mod.all.prop3)
summary(aov(log.mod.all.prop3))
library(car)
library(multcomp)
library(lsmeans)
library(multcompView)
mod1 <- glm(cbind(Days_Survived, DaysDead)~Treatment_Temperature*Species2,
family = quasibinomial(link = "logit"),
data = mort.data)
summary(mod1)
drop1(mod1)
mod2 <- glm(cbind(Days_Survived, DaysDead)~Treatment_Temperature + Species2,
family = quasibinomial(link = "logit"),
data = mort.data)
anova(mod1, mod2, test = "LRT")
summary(mod1)
mc <- lsmeans(mod1, ~ Species2, adjust = "Tukey")
summary(mc)
cld(mc, alpha = 0.05, Letters = letters, adjust = "tukey")
summary(mod1)
summary(log.mod.all.prop3)
var(DaysDead)
var(mort.data$DaysDead)
mean(mort.data$DaysDead)
sum(residuals(log.mod.all.prop3, type = "deviance")^2)
summary(mod1)
9.71/1.72
summary(log.mod.all.prop3)
summary(mod1)
df.90 <- c(110, 65, 232, 432, 193, 90, 244)
df.today <- c(73, 88, 200, 118, 166, 50, 204)
binom.test(6,7,0.5)
t.test(df.90, df.today)
mean(df.90)
mean(df.today)
?t.test
t.test(df.90, df.today, paired = TRUE)
0.03*0.9/0.706
expected <- c(37 9 14 40)
expected <- c(37, 9, 14, 40)
obs.prop <- c(0.56, 0.19, 0.19, 0.06)
expected*obs.prop
sum(observed)
observed <- c(37, 9, 14, 40)
ex.prop <- c(0.56, 0.19, 0.19, 0.06)
sum(observed)
100*exp.prop
100*ex.prop
expected <- 100*ex.prop
(observed-expected)^2/expected
sum((observed-expected)^2/expected)
benguela <- read.csv("http://faraway.neu.edu/data/assn3_benguela.csv")
benguela <- read.csv("http://faraway.neu.edu/data/assn3_benguela.csv")
california <- read.csv("http://faraway.neu.edu/data/assn3_california.csv")
california <- read.csv("http://faraway.neu.edu/data/assn3_california.csv")
canary <- read.csv("http://faraway.neu.edu/data/assn3_canary.csv")
canary <- read.csv("http://faraway.neu.edu/data/assn3_canary.csv")
humboldt <- read.csv("http://faraway.neu.edu/data/assn3_humboldt.csv")
period.ben <- ifelse(benguela$year >= 1950 & benguela$year <= 2024, print("before"), print("after"))
period.ben
period.cal <- ifelse(california$year >= 1950 & california$year <= 2024, print("before"), print("after"))
period.cal
period.can <- ifelse(canary$year >= 1950 & canary$year <= 2024, print("before"), print("after"))
period.hum <- ifelse(humboldt$year >= 1950 & humboldt$year <= 2024, print("before"), print("after"))
means.ben <- rowMeans(benguela[,c(1:22)])
data.ben <- (data.frame(means.ben, benguela$year, period.ben))
colnames(data.ben) <- c("means.ben","year","period")
means.cal <- rowMeans(california[c(1:22)])
data.cal <- data.frame(means.cal, california$year, period.cal)
colnames(data.cal) <- c("means.cal","year","period")
means.can <- rowMeans(canary[c(1:22)])
data.can <- data.frame(means.can, canary$year, period.can)
colnames(data.can) <- c("means.can","year","period")
means.hum <- rowMeans(humboldt[c(1:22)])
data.hum <- data.frame(means.hum, humboldt$year, period.hum)
colnames(data.hum) <- c("means.hum","year","period")
means.ben.before <- subset(data.ben, subset = data.ben$period == "before", select = means.ben)
qqnorm(means.ben.before$means.ben)
qqline(means.ben.before$means.ben)
shapiro.test(means.ben.before$means.ben)
means.ben.after <- subset(data.ben, subset = data.ben$period == "after", select = means.ben)
qqnorm(means.ben.after$means.ben)
qqline(means.ben.after$means.ben)
shapiro.test(means.ben.after$means.ben)
means.cal.before <- subset(data.cal, subset = data.cal$period == "before", select = means.cal)
qqnorm(means.cal.before$means.cal)
qqline(means.cal.before$means.cal)
shapiro.test(means.cal.before$means.cal)
means.cal.after <- subset(data.cal, subset = data.cal$period == "after", select = means.cal)
qqnorm(means.cal.after$means.cal)
qqline(means.cal.after$means.cal)
shapiro.test(means.cal.after$means.cal)
means.can.before <- subset(data.can, subset = data.can$period == "before", select = means.can)
qqnorm(means.can.before$means.can)
qqline(means.can.before$means.can)
shapiro.test(means.can.before$means.can)
means.can.after <- subset(data.can, subset = data.can$period == "after", select = means.can)
qqnorm(means.can.after$means.can)
qqline(means.can.after$means.can)
shapiro.test(means.can.after$means.can)
means.hum.before <- subset(data.hum, subset = data.hum$period == "before", select = means.hum)
qqnorm(means.hum.before$means.hum)
qqline(means.hum.before$means.hum)
shapiro.test(means.hum.before$means.hum)
means.hum.after <- subset(data.hum, subset = data.hum$period == "after", select = means.hum)
qqnorm(means.hum.after$means.hum)
qqline(means.hum.after$means.hum)
shapiro.test(means.hum.after$means.hum)
wilcox.test(means.ben.before$means.ben, means.ben.after$means.ben)
wilcox.test(means.cal.before$means.cal, means.cal.after$means.cal)
wilcox.test(means.can.before$means.can, means.can.after$means.can)
wilcox.test(means.can.before$means.can, means.can.after$means.can)
means.ben.before
ben.b.mean <- sapply(means.ben.before, FUN = mean)
ben.b.mean
