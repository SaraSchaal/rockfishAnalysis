{
    "collab_server" : "",
    "contents" : "# This code is meant to fit thermal performance curves using various \n# thermal performance curve (TPC) models. \n\n# The main function starts after model functions have been loaded. You \n# we need to specify the Data file, the Model you want to run \n# (\"Boltzmann\", \"Schoolfield\" or \"all\" if we want to run both). You also \n# need to specify if you want to save plots (PLOT=TRUE) (one figure will be \n# plot for each model) or if you are running both models we can choose the \n# Overplot=TRUE selection in case that you want a unique figure with both \n# models overlaid.\n\n# Depending on if you want to use the Schoolfield model with explicit\n# T_pk parameter or not you have to set the SchoolTPk as TRUE or FALSE\n\n# Requires package minpack.lm for the NLLS (which implements the more \n# robust Levenberg-Marqualdt algorithm) and ggplot2 for plotting, neither \n# of which is not part of the R standard libraries -- Please install if \n# necessary\n\n#### Tref is specified at the beginning as GlobalEnvironment, so change \n# the value here in case you need it.\n\n# Required packages...\nlibrary(ggplot2, graphics)\nlibrary(lattice)\nlibrary(minpack.lm)  ### The nls is now run under this package using the nlsLM instead of nls\nlibrary(sme)\nlibrary(truncnorm)\n\n#############################\n# F  U  N  C  T  I  O  N  S #\n#############################\n\n#### assign Tref as GlobalEnv\n# Tref is the standardization temperature (in K). \n# This needs to be any value below the peak of the curve.\nassign(\"Tref\", 0 + 273.15, envir = .GlobalEnv) ## Set to Inf if you want to remove the normalization, so 1/Tref will be 0 \n\n#### Estimate STARTING VALUES for the nls\n\nGetE <- function(tmp, rate, T.p, k=8.62e-5)\n    {\n    # Estimate starting value for E, taking linear regression using the rise part\n    # of the curve only.\n    # ~~~ Parameters ~~~\n    # tmp  : temperature data (in K).\n    # rate : rate data corresponding to temperature above.\n    # T.p  : temperature at which rate peaks, used as a cutoff point.\n    # k    : Boltzmann constant.\n    \n\n  tmp.w <- which(tmp <= T.p)\n  if (length(tmp.w) > 1 & length(unique(tmp[tmp.w]))>1)\n  {\n    m <- lm(log(rate[tmp.w]) ~ I(1 / (k * (tmp[tmp.w]))))\n     return(abs(summary(m)$coefficients[2, c('Estimate', 'Std. Error')]))\n  } else\n  {\n    return(c(0.7,2))  # Arbitrary estimate if we can't do regression.\n  }\n\n}\n\nGetlnB0 <- function(tmp, rate)\n{\n    # Estimate starting value for the normalising constant.\n    # ~~~ Parameters ~~~\n    # tmp   : temperature data (in K).\n    # rate  : rate data corresponding to temperature above.\n    # T.ref : estimate normalising constant at this temperature (in K).\n\n    if (min(tmp,na.rm=TRUE) > Tref)\n        {\n    return(log(min(rate[1],na.rm=TRUE)))\n} else\n    {\n    return(log(max(rate[which(tmp <= Tref)],na.rm=TRUE)))\n}\n}\n\n\nGetTpk <- function(tmp, rate)\n{\n    # Temperature at which the rate is maximised (estimate of T.peak).\n    # ~~~ Parameters ~~~\n    # tmp  : Temperature data (in K).\n    # rate : Rate data corresponding to temperature above.\n\n    return(max(tmp[which.max(rate)]))\n}\n\n\n\n\n###################### Boltzmann - Arrhenius model.\nBoltzmann.Arrhenius <- function(lnB0, E, temp) {\n    \n    # Boltzmann's constant. Units imply that E is in eV.\n    k <- 8.62e-5 \n\n    # lnB0 is the normalization constant.  \n    # E is the activation energy.\n    # Tref is the standardization temperature (in K).\n    \n    calc <- lnB0 - E/k * (1/temp - 1/Tref)\n\n    return(calc)\n}\n\n###################### Schoolfield type models ######################\n\n# Schoolfield function runs two different schoolfield models, one with\n# explicit T_pk parameter (then we need to set SchoolTpk as TRUE),\n#or the original one.\n\nSchoolfield <- function(lnB0, E, E_D, T_h, temp, SchoolTpk=TRUE)\n{ \n    # PARAMETERS/INPUTS (all temperatures in Kelvin) -\n    # Boltzmann's constant. Units imply that E is in eV.\n    k <- 8.62e-5 \n    # temp   : temperature values to evaluate function at (single, scalar or vector of values)\n    # lnB0     : Normalisation constant (log transformed)\n    # E      : Activation energy (> 0)\n    # E_D    : High temperature de-activation energy (> 0) \n    # Tref   : Standardization (reference) temperature; set to 0 if not wanted. To do    # this the whole term 1/Tref should be 0, so Tref has to be set to Inf\n    # T_h (if SchoolTpk=TRUE): Temperature at which trait reaches peak value (Tpk)\n    # T_h (if not Tpk)   : High temperature at which have of the enzyme units, on \n    # \t\t\t\taverage are inactiveated.\n\n    if (SchoolTpk==TRUE) # Sharpe-Schoolfield model with explicit T_pk parameter\n        {\n    return(lnB0 + log(exp((-E/k) * ((1/temp)-(1/Tref)))/(1 + (E/(E_D - E)) * exp(E_D/k * (1/T_h - 1/temp)))))\n\n} else { # Standardised Sharpe-Schoolfield's model with low-temp inactivation term removed, slightly modified                                                                                                                     \n      return(lnB0 + log(exp((-E/k) * ((1/temp) - (1/Tref)))/(1 + exp((E_D/k) * (1/T_h - 1/temp))))) }\n\n}\n\n####################################################################################\n############################# M  A  I  N    C  O  D  E #############################\n####################################################################################\n\nTPCFit <- function(Data,PLOT=TRUE,OverPLOT=FALSE,Model=\"Schoolfield\",SchoolTpk=TRUE,rand.st=FALSE, n.rand=20){ \n    # MODEL can be also \"Boltzmann\" or \"all\" for both\n    # School can be TRUE (explicit Tpk parameter) or FALSE (Standardised Schoolfield)\n    # rand.st    : boolean - use random starting values?\n    # n.rand     : numeric - number of random starting values used (if\n    #              `rand.st=TRUE`).\n\n    if (OverPLOT==TRUE) PLOT <- FALSE\n    \n\n    # Loads Data\n    curvespt <- Data\n    curvespt$StandardisedTraitValue <- as.numeric(curvespt$StandardisedTraitValue)\n    curvespt$FinalID <- as.character(curvespt$FinalID)\n\n    # Merges ConTemp and AmbientTemp in the same column\n    NATemp <- which(is.na(curvespt$ConTemp))\n    NAAmbientTemp <- which(!is.na(curvespt$AmbientTemp[NATemp]))\n    curvespt$ConTemp[NATemp][NAAmbientTemp] <- curvespt$AmbientTemp[NATemp][NAAmbientTemp]\n    curvespt$ConTemp <- as.numeric(curvespt$ConTemp)\n\n    # Transform temperatures to Kelvin and log-transform the\n    # trait values.\n    curvespt$K <- curvespt$ConTemp + 273.15\n\n\n    ###################################################################\n    # Create unique species/individual IDs, with a series of vectors. #\n    ###################################################################\n\n    # Initialize the current ID at 0. You'll see why later...\n    current_ID <- 0\n\n    # Initialize an empty vector of species IDs (as a number).\n    id <- c()\n\n    # Initialize an empty vector of species names.\n    id_spp <- c()\n\n    # Initialize an empty vector of processes (e.g., photosynthesis, respiration).\n    id_process <- c()\n\n    # Read each row of the data frame.\n    for (k in 1:nrow(curvespt))\n        {\n\n    # If the ID of this row is different from the current ID...\n    if ( current_ID != curvespt$FinalID[k])\n\t{\n    \n    # Change the current ID to the one found in this row.\n    current_ID <- curvespt$FinalID[k]\n    \n    # Add information for this species to the 3 vectors \n    # that we initialized above.\n    id <- c(id, current_ID)\n    #id_spp <- c(id_spp, curvespt$Consumer[k])\n    #id_process <- c(id_process, curvespt$StandardisedTraitName[k])\n}\n}\n\n    # Initialize empty vectors to store the parameter estimates\n    # that will be obtained.\n\n    if (Model==\"Boltzmann\" | Model==\"all\")\n        {\n    E_boltz <- c()\n    lnB0_boltz <- c()\n    T_pk_boltz <- c()\n    P_pk_boltz <- c()\n    AIC_boltz <- c()\n    r_sq_boltz <- c()\n}\n\n    if (Model==\"Schoolfield\" | Model==\"all\")\n        {\n    lnB0_sch <- c()\n    E_sch <- c()\n    E_D_sch <- c()\t\n    T_h_sch <- c()\n    T_pk_sch <- c()\n    P_pk_sch <- c()\n    AIC_sch <- c()\n    r_sq_sch <- c()\n   \n}\n\n    if (Model==\"all\"){\n        selected_model<- c()}\n\n    P_pkBug <- c()\n    lnB0Bug <- c()\n    AftPk <-c()\n    BefPk <- c()\n    MinVal <- c()\n\n\n    # Go through every single species ID and try to fit the the selected models.\n    for(i in 1:length(id)) \n        { \n\n    # Get only the part of the data that correspond to that particular ID.\n    current_dataset <- curvespt[curvespt$FinalID == id[i],]\n\n    \n    ## If there are negative values, substract the minimum value. This value is recorded in the results table in case you want to re-add\n\n    if (min(current_dataset$StandardisedTraitValue,na.rm=TRUE)<=0){\n        MinVal <- c(MinVal,min(current_dataset$StandardisedTraitValue))\n        current_dataset$StandardisedTraitValue <-current_dataset$StandardisedTraitValue - MinVal\n        current_dataset <-current_dataset[-which(current_dataset$StandardisedTraitValue==0),]} else {\n                                                                                                   MinVal <- c(MinVal,NA)}\n    \n\n    ## Calculates number of data points after and before the Tpk\n    Order <- order(current_dataset$K)\n    Max <- which.max(current_dataset$StandardisedTraitValue[Order])\n    if (length(Max)>0){\n    AftPk <- c(AftPk,(length(current_dataset$StandardisedTraitValue)-Max))\n    BefPk <- c(BefPk,(Max-1))} else {\n    AftPk <- c(AftPk,NA)\n    BefPk <- c(BefPk,NA)} \n\n    # Runs only if we have at least 5 data points and more than 5 diff temperatures\n    if (length(unique(current_dataset$StandardisedTraitValue))>=5 && length(unique(current_dataset$K))>=5)\n        {\n\n    # Estimate T.h as being approximately T.peak.\n    T.h.st  <- GetTpk(tmp=current_dataset$K, rate=current_dataset$StandardisedTraitValue)\n    E.st    <- GetE(tmp=current_dataset$K, rate=current_dataset$StandardisedTraitValue, T.p=T.h.st)\n    lnB.st <- GetlnB0(tmp=current_dataset$K, rate=current_dataset$StandardisedTraitValue)\n\n    if (Model==\"Boltzmann\" | Model==\"all\"){\n        ###############################\n        # Boltzmann - Arrhenius model #\n        ###############################\n\n   \n\n        # Initialize the fitting variable to NA (empty).\n        boltzmann_nls <- NA\n\n        \n        # Try and fit the model.\n        try( \n            boltzmann_nls <- nlsLM(\n                log(StandardisedTraitValue) ~ Boltzmann.Arrhenius(lnB0, E, temp = K),\n                start = c(lnB0 = lnB.st, E = E.st[1]),\n                lower=c(lnB0=-Inf, E=0),\n                upper=c(lnB0=Inf,  E=Inf),\n                control=list(minFactor=1 / 2^16, maxiter=1e4),\n                data = current_dataset, \n                na.action=na.omit),\n            silent=TRUE\n            )\n        \n        # If fitting worked ...\n        if(!is.na(boltzmann_nls[1])) \n            { \n\n    # Collect the parameter estimates...\n    if (!is.na(MinVal)){ ## Add MinVal if it was substracted\n        if (Model==\"Boltzmann\") lnB0Bug <- c(lnB0Bug,TRUE) ## When both models are fit, lnB0Bug is attached in Schoolfield\n    }else {        \n         if (Model==\"Boltzmann\") lnB0Bug <- c(lnB0Bug,FALSE)\n     }\n    lnB0_boltz <- c(lnB0_boltz, coef(boltzmann_nls)[\"lnB0\"])\n    E_boltz <- c(E_boltz, coef(boltzmann_nls)[\"E\"])\n    AIC_boltz<- c(AIC_boltz, AIC(boltzmann_nls))\n\n    # Calculate the R squared value as: 1 - (rss/tss)\n    rss <- sum((exp(predict(boltzmann_nls)) - \n                    current_dataset$StandardisedTraitValue)^2, \n               na.rm = TRUE)\n    tss <- sum(\n        (current_dataset$StandardisedTraitValue - \n             mean(current_dataset$StandardisedTraitValue, na.rm = TRUE))^2, \n        na.rm = TRUE)\n    \n    if ( tss != 0 )\n        {\n    r_sq_boltz <- c(r_sq_boltz, 1 - (rss/tss))\n} else\n    {\n    r_sq_boltz <- c(r_sq_boltz, 1)\n}\n    \n    # Calculate the peak of the curve and its \n    # corresponding temperature value.\n    curr_prediction <- predict(boltzmann_nls)\n    for (j in 1:length(curr_prediction))\n        {\n    \n    # If we found the maximum performance, exit the loop.\n    if (curr_prediction[j] == max(curr_prediction))\n        {\n    break\n}\n}\n    \n    T_pk_boltz <- c(T_pk_boltz, current_dataset$K[j])\n    P_pk_boltz <- c(P_pk_boltz, current_prediction$K[j])\n    if (!is.na(MinVal)){ ## If MinVal was substracted        \n        if (Model==\"Boltzmann\") P_pkBug <- c(P_pkBug,TRUE) ## When both models are fit, PpkBug is attached in Schoolfield\n\n    }else {\n         if (Model==\"Boltzmann\") P_pkBug <- c(P_pkBug,FALSE)\n     }\n\n\n    #######################################\n    # Plotting Boltzmann - Arrhenius' fit #\n    #######################################\n    \n    # Create a name for the output file using:\n    #\t- the original id number\n    #   - the species name\n    #   - the model\n    output_name <- paste(\n        current_dataset$FinalID[1], \n        current_dataset$Consumer[1], \n        'Boltzmann_Arrhenius',\n        sep = \"_\"\n        )\n    \n    # Remove any characters that won't look good in a file name,\n    # using a regular expression.\n    output_name <- gsub(\"[^\\\\w|\\\\s](|)\", \"\", output_name, perl=TRUE)\n    # Convert spaces to underscores.\n    output_name <- gsub(\"\\\\s+\", \"_\", output_name, perl=TRUE)\n    \n    # CHANGE THIS to set an alternative output directory.\n    outdir <- \"./\"\n    \n    # Generate predictions from the model fit...\n    tmp_temps <- seq(min(\n        floor(current_dataset$K)), \n                     ceiling(max(current_dataset$K)\n                             ), length = 200)\n    \n    tmp_model <- exp(Boltzmann.Arrhenius(\n        coef(boltzmann_nls)[\"lnB0\"],\n        coef(boltzmann_nls)[\"E\"],\n        tmp_temps\n        ))\n    \n    ModelToPlotB <- data.frame(\n        Temperature = tmp_temps - 273.15, \n        TraitValue = tmp_model\n        )\n    \n    \n    # Prepare the data points of the original values.\n    DataToPlot <- data.frame(\n        Temperature = current_dataset$K - 273.15, \n        TraitValue = current_dataset$StandardisedTraitValue\n        )\n    DataToPlot <- na.omit(DataToPlot)\n\n\n    #### If we want individual plots\n    if (PLOT==TRUE) {\n        # Plot!\n        p <- ggplot() + geom_point(data = DataToPlot, aes(x = Temperature, \n                                       y = TraitValue), size = 3, col = \"black\", bg = \"lightcyan2\", \n                                   alpha = 0.7, pch = 21) + \n            geom_line(data = ModelToPlotB, \n                      aes(x = Temperature, y = TraitValue), colour = \"#1b9e77\", \n                      lwd = 1.3) +\n                \n                ggtitle(paste(current_dataset$Consumer[1])) +\n                    xlab(expression(paste(\"Temperature (\", degree, C, \")\"))) + \n                        ylab(current_dataset$StandardisedTraitName[1]) +\n                            theme_bw() + theme(plot.title = element_text(size = 12), \n                                               axis.title = element_text(size = 10)) +\n                                annotate(\"text\", size = 3, label=             \n                                             paste(\"R^2 boltz=\", sprintf(\"%.2f\", r_sq_boltz[i]), \"\\nE boltz=\", format(coef(boltzmann_nls)[\"E\"], digits = 3),\"\\nAIC boltz=\",format(AIC(boltzmann_nls),digits=3)), \n                                         x = min(DataToPlot[, \"Temperature\"]),\n                                         y = mean(DataToPlot[, \"TraitValue\"]),\n                                         hjust=0,\n                                         fontface = 3)\n        \n        # Save it as an svg file.\n        svg_file <- paste(outdir, gsub(\"/|#\", \"\", output_name), \".svg\", sep=\"\")\n            ggsave(filename = svg_file, plot = p, height = 4, width = 4.2)\n    }\n    \n    \n} else # If fitting failed ...\n    {\n    # Populate the vectors with missing values.\n    E_boltz <- c(E_boltz, NA)\n    lnB0_boltz <- c(lnB0_boltz, NA)\n    T_pk_boltz <- c(T_pk_boltz, NA)\n    P_pk_boltz <- c(P_pk_boltz, NA)\n    AIC_boltz <- c(AIC_boltz, NA)\n    r_sq_boltz <- c(r_sq_boltz, NA)\n    if (Model==\"Boltzmann\") { ## When both models are fit, this is attached in Schoolfield\n        lnB0Bug <- c(lnB0Bug,NA)\n        P_pkBug <- c(P_pkBug,NA)}\n}\n    }\n\n    if (Model==\"Schoolfield\" | Model==\"all\"){\n        \n    #####################\n    # Schoolfield model #\n    #####################\n  \n\n        if (rand.st)\n            {\n    # Create randomised starting points.\n    E.st.pe <- E.st[1]  # Slope value.\n    T.h.st  <- c(T.h.st, rnorm(n.rand-1, mean=T.h.st, sd=15))\n    # We need truncated normal to ensure we don't get negative values of E.\n    E.st   <- c(E.st.pe, rtruncnorm(n.rand-1, a=0, b=Inf, mean=E.st[1], sd=2 * E.st[2]))\n    lnB.st   <- exp(lnB.st)\n    # Randomise on linear scale. Again, we don't want negative rates.\n    lnB.st <- c(lnB.st, log(rtruncnorm(n.rand-1, a=0, b=Inf, mean=lnB.st, sd=lnB.st / 2)))\n\n    # We'll select the best model using AICc. Many of these turn out to be\n    # similar.\n    aics.out <- rep(NA, n.rand)\n\n    for (h in 1:n.rand)\n        {\n    schoolfield_nls <- try(nlsLM(\n        log(StandardisedTraitValue) ~ Schoolfield(lnB0, E, E_D, T_h, temp = K,SchoolTpk=SchoolTpk), \n        start=c(lnB0=lnB.st[h], E=E.st[h], E_D=4*E.st[h],T_h=T.h.st[h]),\n        lower=c(lnB0=-Inf, E=0,  E_D=0,  T_h=250),\n        upper=c(lnB0=Inf,  E=30, E_D=50, T_h=350),\n        data=current_dataset,control=list(minFactor=1 / 2^16, maxiter=1024)),\n                           silent=TRUE)\n\n    if (class(schoolfield_nls) != 'try-error')\n        {\n    aics.out[h] <- AICc(schoolfield_nls)\n}\n}\n    w <- which.min(aics.out)\n\n    if (length(w) > 0)\n        {\n    schoolfield_nls <- try(nlsLM(\n        log(StandardisedTraitValue) ~ Schoolfield(lnB0, E, E_D, T_h, temp = K,SchoolTpk=SchoolTpk), \n        start=c(lnB0=lnB.st[w], E=E.st[w], E_D=4*E.st[w],T_h=T.h.st[w]),\n        lower=c(lnB0=-Inf, E=0,  E_D=0,  T_h=250),\n        upper=c(lnB0=Inf,  E=30, E_D=50, T_h=350),\n        data=current_dataset,control=list(minFactor=1 / 2^16, maxiter=1024)),\n                           silent=TRUE)\n    \n} else\n    {\n    schoolfield_nls <- NA\n}\n} else\n    {\n\n\n    schoolfield_nls <- NA\n    try( \n        schoolfield_nls <- nlsLM(\n            log(StandardisedTraitValue) ~ Schoolfield(lnB0, E, E_D, T_h, temp = K,SchoolTpk=SchoolTpk), \n            start=c(lnB0 = lnB.st, E = E.st, E_D = 4*E.st, T_h=T.h.st),\n            lower=c(lnB0=-Inf,   E=0,    E_D=0, T_h=0),\n            upper=c(lnB0=Inf,    E=Inf,  E_D=Inf, T_h=Inf),\n            data=current_dataset, control=list(minFactor=1 / 2^16, maxiter=1024)),\n        silent=TRUE)\n    \n}\n        \n    # If fitting worked ...\n    if(!is.na(schoolfield_nls[1])) \n\t{ \n\n    # Collect the parameter estimates..\n    if (!is.na(MinVal)){ ## Add MinVal if it was substracted\n        lnB0Bug <- c(lnB0Bug,TRUE)        \n    }else {\n         lnB0Bug <- c(lnB0Bug,FALSE)\n     }\n    lnB0_sch <- c(lnB0_sch, (coef(schoolfield_nls)[\"lnB0\"]))\n    E_sch <- c(E_sch, coef(schoolfield_nls)[\"E\"])\n    E_D_sch <- c(E_D_sch, coef(schoolfield_nls)[\"E_D\"])\n    T_h_sch <- c(T_h_sch, coef(schoolfield_nls)[\"T_h\"])\n    AIC_sch<- c(AIC_sch, AIC(schoolfield_nls))\n    \n    # Calculate the R squared value as: 1 - (rss/tss)\n    rss <- sum((exp(predict(schoolfield_nls)) - \n                    current_dataset$StandardisedTraitValue)^2, \n               na.rm = TRUE)\n    tss <- sum(\n        (current_dataset$StandardisedTraitValue - \n             mean(current_dataset$StandardisedTraitValue, na.rm = TRUE))^2, \n        na.rm = TRUE)\n    \n    if ( tss != 0 )\n        {\n    r_sq_sch <- c(r_sq_sch, 1 - (rss/tss))\n} else\n    {\n    r_sq_sch <- c(r_sq_sch, 1)\n}\n    \n    # Calculate the peak of the curve and its \n    # corresponding temperature value.\n    curr_prediction <- predict(schoolfield_nls)\n    for (j in 1:length(curr_prediction))\n        {\n    # If we found the maximum performance, exit the loop.\n    if (curr_prediction[j] == max(curr_prediction))\n        {\n    break\n}\n}    \n    \n    T_pk_sch <- c(T_pk_sch, current_dataset$K[j])\n    P_pk_sch <- c(P_pk_sch, curr_prediction[j])\n    if (!is.na(MinVal)){ ## If MinVal  was substracted\n        P_pkBug <- c(P_pkBug,TRUE)       \n    }else {\n         P_pkBug <- c(P_pkBug,FALSE)\n     }\n\n\n  \n\n    ##############################\n    # Plotting Schoolfield's fit #\n    ##############################\n    \n    # Create a name for the output file using:\n    #\t- the original id number\n    #   - the species name\n    #   - the model\n    output_name <- paste(\n        current_dataset$FinalID[1], \n        current_dataset$Consumer[1], \n        'Schoolfield',\n        sep = \"_\"\n        )\n    \n    \n    # Remove any characters that won't look good in a file name,\n    # using a regular expression.\n    output_name <- gsub(\"[^\\\\w|\\\\s](|)\", \"\", output_name, perl=TRUE)\n    \n    # Convert spaces to underscores.\n    output_name <- gsub(\"\\\\s+\", \"_\", output_name, perl=TRUE)\n    \n    # CHANGE THIS to set an alternative output directory.\n    outdir <- \"./\"\n    \n    # Generate predictions from the model fit...\n    tmp_temps <- seq(min(\n        floor(current_dataset$K)), \n                     ceiling(max(current_dataset$K)\n                             ), length = 200)\n    \n    tmp_model <- exp(Schoolfield(\n        coef(schoolfield_nls)[\"lnB0\"],\n        coef(schoolfield_nls)[\"E\"],\n        coef(schoolfield_nls)[\"E_D\"],\n        coef(schoolfield_nls)[\"T_h\"],\n        tmp_temps\n        ))\n    \n    ModelToPlotS <- data.frame(\n        Temperature = tmp_temps - 273.15, \n        TraitValue = tmp_model\n        )\n    \n    # Prepare the data points of the original values.\n    DataToPlot <- data.frame(\n        Temperature = current_dataset$K - 273.15,\n        TraitValue = current_dataset$StandardisedTraitValue\n        )\n    DataToPlot <- na.omit(DataToPlot)\n\n\n    #### If we want individual plots\n    if (PLOT==TRUE) {\n        # Plot!\n        p <- ggplot() + geom_point(data = DataToPlot, aes(x = Temperature, \n                                       y = TraitValue), size = 3, col = \"black\", bg = \"lightcyan2\", \n                                   alpha = 0.7, pch = 21) + \n            geom_line(data = ModelToPlotS, \n                      aes(x = Temperature, y = TraitValue), colour = \"#1b9e77\", \n                      lwd = 1.3) +                           \n                ggtitle(paste(current_dataset$Consumer[1])) +\n                    xlab(expression(paste(\"Temperature (\", degree, C, \")\"))) + \n                        ylab(current_dataset$StandardisedTraitName[1]) +\n                            theme_bw() + theme(plot.title = element_text(size = 12), \n                                               axis.title = element_text(size = 10)) +\n                                annotate(\"text\", size = 3, label=             \n                                             paste(\"R^2\",\"sch=\", sprintf(\"%.2f\", r_sq_sch[i]),\"\\nE sch=\", format(coef(schoolfield_nls)[\"E\"], digits = 3),\"\\nAIC sch=\",format(AIC(schoolfield_nls),digits=3)), \n                                         x = min(DataToPlot[, \"Temperature\"]),\n                                         y = mean(DataToPlot[, \"TraitValue\"]),\n                                         hjust=0,\n                                         fontface = 3)\n        \n        # Save it as an svg file.\n        svg_file <- paste(outdir, gsub(\"/|#\", \"\", output_name), \".svg\", sep=\"\")\n            ggsave(filename = svg_file, plot = p, height = 4, width = 4.2)\n\n    }\n} else # If fitting failed ...\n    {\n    # Populate the vectors with missing values.\n    lnB0_sch <- c(lnB0_sch, NA)    \n    lnB0Bug <- c(lnB0Bug,NA)\n    E_sch <- c(E_sch, NA)\n    E_D_sch <- c(E_D_sch, NA)\t\n    T_h_sch <- c(T_h_sch, NA)\n    T_pk_sch <- c(T_pk_sch, NA)\n    P_pk_sch <- c(P_pk_sch, NA)\n    P_pkBug <- c(P_pkBug,NA)\n    AIC_sch <- c(AIC_sch, NA)\n    r_sq_sch <- c(r_sq_sch, NA)\n    lnB0exp1_sch <- c(lnB0exp1_sch,NA)\n    lnB0exp2_sch<- c(lnB0exp2_sch,NA)\n    lnB0exp5_sch<- c(lnB0exp5_sch,NA)\n    lnB0exp10_sch<- c(lnB0exp10_sch,NA)\n}\n\n}\n\n    if (Model==\"all\")\n        {\n\n    if (OverPLOT==TRUE) { ## In case we want both models in the same figure with the overlaid fits.\n        ##############################\n        # Plotting both fits #\n        ##############################\n        \n        # Create a name for the output file using:\n        #\t- the original id number\n        #   - the species name\n        #   - the model\n        output_name <- paste(\n            current_dataset$FinalID[1], \n            current_dataset$Consumer[1], \n            'Schoolfield_Boltz',\n            sep = \"_\"\n            )\n        \n        \n        # Remove any characters that won't look good in a file name,\n        # using a regular expression.\n        output_name <- gsub(\"[^\\\\w|\\\\s](|)\", \"\", output_name, perl=TRUE)\n        \n        # Convert spaces to underscores.\n        output_name <- gsub(\"\\\\s+\", \"_\", output_name, perl=TRUE)\n        \n        # CHANGE THIS to set an alternative output directory.\n        outdir <- \"./\"\n        \n        \n        # Prepare the data points of the original values.\n        DataToPlot <- data.frame(\n            Temperature = current_dataset$K - 273.15, \n            TraitValue = current_dataset$StandardisedTraitValue\n            )\n        DataToPlot <- na.omit(DataToPlot)\n\n        if(!is.na(MinVal)){\n            DataToPlot$TraitValue <- DataToPlot$TraitValue+MinVal\n        }\n        \n        ## Trait Units for plot\n        Unit <- current_dataset$StandardisedTraitUnit[1]\n        if (is.na(Unit)) Unit <- current_dataset$StandardisedTraitUnit[1]\n        \n        # Plot!\n        p <- ggplot() + geom_point(data = DataToPlot, aes(x = Temperature, \n                                       y = TraitValue), size = 3, col = \"black\", bg = \"lightcyan2\", \n                                   alpha = 0.7, pch = 21) + \n            geom_line(data = ModelToPlotB, \n                      aes(x = Temperature, y = TraitValue), colour = \"#1b9e77\", \n                      lwd = 1.3) +            \n                geom_line(data = ModelToPlotS, \n                          aes(x = Temperature, y = TraitValue), colour = \"red\", \n                          lwd = 1.3) +             \n                    ggtitle(paste(current_dataset$Consumer[1])) +\n                        xlab(expression(paste(\"Temperature (\", degree, C, \")\"))) + \n                            ylab(paste(current_dataset$StandardisedTraitName[1],\"\\n\",Unit)) +\n                                theme_bw() + theme(plot.title = element_text(size = 12), \n                                                   axis.title = element_text(size = 10)) +\n                                    annotate(\"text\", size = 3, label=             \n                                                 paste(\"R^2\",\"sch=\", sprintf(\"%.2f\", r_sq_sch[i]),\"\\nE sch=\", format(coef(schoolfield_nls)[\"E\"], digits = 3),\"\\nAIC sch=\",format(AIC(schoolfield_nls),digits=3),\"\\nR^2 boltz=\", sprintf(\"%.2f\", r_sq_boltz[i]), \"\\nE boltz=\", format(coef(boltzmann_nls)[\"E\"], digits = 3),\"\\nAIC boltz=\",format(AIC(boltzmann_nls),digits=3)), \n                                             x = min(DataToPlot[, \"Temperature\"]),\n                                             y = mean(DataToPlot[, \"TraitValue\"]),\n                                             hjust=0,\n                                             fontface = 3)\n        \n        # Save it as an svg file.\n        svg_file <- paste(outdir, gsub(\"/|#\", \"\", output_name), \".svg\", sep=\"\")\n            ggsave(filename = svg_file, plot = p, height = 4, width = 4.2)\n\n    }     \n\n    ##################################################################\n    # Compare the two models using the Akaike Information Criterion. #\n    ##################################################################\n    \n    # If both models failed to fit, add NA. \n    if (is.na(AIC_sch[i]) && is.na(AIC_boltz[i]))\n\t{\n    selected_model <- c(selected_model, NA)\n    \n    # If only one of the two models could be fit, that is \n    # automatically the winner!\n} else if (is.na(AIC_sch[i]) && !is.na(AIC_boltz[i]))\n      {\n    selected_model <- c(selected_model, 'boltzmann')\n} else if (is.na(AIC_boltz[i]) && !is.na(AIC_sch[i]))\n      {\n    selected_model<- c(selected_model, \"schoolfield\")\t\n    \n    # If both models were able to fit and Schoolfield's AIC\n    # was lower, then that is the better model for this curve.\n} else if (AIC_sch[i] < AIC_boltz[i])\n      {\n    selected_model<- c(selected_model,  \"schoolfield\")\n    \n    # And the opposite for the Boltzmann - Arrhenius model.\n} else\n    {\n    selected_model<- c(selected_model,  \"boltzmann\")\n}\n}\n\n}  else # If there are not enough values\n    {\n    \n    # Populate the vectors with missing values.\n    if (Model==\"Schoolfield\" | Model==\"all\"){\n        lnB0_sch <- c(lnB0_sch, NA)        \n        lnB0Bug <- c(lnB0Bug,NA)\n        E_sch <- c(E_sch, NA)\n        E_D_sch <- c(E_D_sch, NA)\t\n        T_h_sch <- c(T_h_sch, NA)\n        T_pk_sch <- c(T_pk_sch, NA)\n        P_pk_sch <- c(P_pk_sch, NA)\n        P_pkBug <- c(P_pkBug,NA)\n        AIC_sch <- c(AIC_sch, NA)\n        r_sq_sch <- c(r_sq_sch, NA)\n      \n    }    \n    # Populate the vectors with missing values.\n    if (Model==\"Boltzmann\" | Model==\"all\"){\n        E_boltz <- c(E_boltz, NA)\n        lnB0_boltz <- c(lnB0_boltz, NA)\n        T_pk_boltz <- c(T_pk_boltz, NA)\n        P_pk_boltz <- c(P_pk_boltz, NA)\n        AIC_boltz <- c(AIC_boltz, NA)\n        r_sq_boltz <- c(r_sq_boltz, NA)}\n    \n    if (Model==\"Boltzmann\") { ## When both models are fit, this is attached in Schoolfield\n        lnB0Bug <- c(lnB0Bug,NA)\n        P_pkBug <- c(P_pkBug,NA)}\n}\n}\n\n\n    ##################################################################\n    # RESULTS FILE #\n    ##################################################################\n  \n\n    if (Model==\"all\"){\n        # Compile all data into a data frame.\n        results <- data.frame(\n            id, E_boltz, E_sch, lnB0_boltz,lnB0_sch, lnB0Bug, E_D_sch, \n            T_h_sch, T_pk_boltz, T_pk_sch, P_pk_boltz, P_pk_sch, P_pkBug,AIC_boltz, \n            AIC_sch, r_sq_boltz, r_sq_sch, AftPk,BefPk,selected_model, MinVal\n            )}\n\n    if (Model==\"Schoolfield\"){\n        results <- data.frame(\n            id, E_sch, lnB0_sch,  lnB0Bug, E_D_sch, \n            T_h_sch,  T_pk_sch, P_pk_sch, P_pkBug,\n            AIC_sch,  r_sq_sch, AftPk,BefPk, MinVal\n            )}\n\n    if (Model==\"Boltzmann\"){\n        results <- data.frame(\n            id, E_boltz, lnB0_boltz,lnB0Bug,\n            T_pk_boltz, P_pk_boltz, P_pkBug,\n            AIC_boltz,  r_sq_boltz, AftPk,BefPk, MinVal    )}\n\n\n    # Write the results as a CSV file.\n    write.csv(results, file = \"results.csv\", row.names = FALSE)\n\n    return()\n}\n\n",
    "created" : 1479267443437.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3437187911",
    "id" : "CB693E0D",
    "lastKnownWriteTime" : 1471395114,
    "last_content_update" : 1471395114,
    "path" : "~/Downloads/TPCFittingChoi.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}