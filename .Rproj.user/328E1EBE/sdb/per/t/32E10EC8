{
    "collab_server" : "",
    "contents" : "######################################################################################################################\n############################################ TPC Fitting Code ########################################################\n\n#### This code is meant to fit thermal performance curves using either Boltzmann and Arrhenius models or both. After loading the model functions, the main function starts. Here we need to specify the Data file, the Model we want to run (\"Boltzmann\", \"Schoolfield\" or \"all\" if we want to run both). We also need to tell if we want to save plots (PLOT=TRUE) (one figure will be plot for each model) or if we are running both models we can choose the Overplot=TRUE selection in case that we want a unique figure with both models overlaid.\n#### Tref is specified at the beginning as GlobalEnvironment, so change the value here in case you need it.\n\n\n# Required packages...\nlibrary(ggplot2)\nrequire(graphics)\nlibrary(lattice)\nlibrary(minpack.lm)  ### The nls is now run under this package using the nlsLM instead of nls\n\n#############################\n# F  U  N  C  T  I  O  N  S #\n#############################\n\n\n#### assign Tref as GlobalEnv\n# T_ref is the standardization temperature (in K). \n# This needs to be any value below the peak of the curve.\nassign(\"Tref\", 278.5, envir = .GlobalEnv) \n\n#### Estimate STARTING VALUES for the nls\n\nGetE <- function(tmp, rate, T.p, k=8.62e-5)\n    {\n    # Estimate starting value for E, taking linear regression using the rise part\n    # of the curve only.\n    # ~~~ Parameters ~~~\n    # tmp  : temperature data (in K).\n    # rate : rate data corresponding to temperature above.\n    # T.p  : temperature at which rate peaks, used as a cutoff point.\n    # k    : Boltzmann constant.\n    \n    tmp.w <- which(tmp <= T.p)\n    if (length(tmp.w) > 1)\n        {\n    m <- lm(log(rate[tmp.w]) ~ I(1 / (k * (tmp[tmp.w]))))\n    return(abs(summary(m)$coefficients[2, 1]))\n} else\n    {\n    return(0.6)\n}\n}\n\nGetB0 <- function(tmp, rate)\n{\n    # Estimate starting value for the normalising constant.\n    # ~~~ Parameters ~~~\n    # tmp   : temperature data (in K).\n    # rate  : rate data corresponding to temperature above.\n    # T.ref : estimate normalising constant at this temperature (in K).\n\n    if (min(tmp,na.rm=TRUE) > Tref)\n        {\n    return(log(min(rate[1],na.rm=TRUE)))\n} else\n    {\n    return(log(max(rate[which(tmp <= Tref)],na.rm=TRUE)))\n}\n}\n\n\nGetTpk <- function(tmp, rate)\n{\n    # Temperature at which the rate is maximised (estimate of T.peak).\n    # ~~~ Parameters ~~~\n    # tmp  : Temperature data (in K).\n    # rate : Rate data corresponding to temperature above.\n\n    return(max(tmp[which.max(rate)]))\n}\n\n\n\n###################### Boltzmann - Arrhenius model.\nBoltzmann.Arrhenius <- function(B0, E, temp) {\n    \n    # Boltzmann's constant. Units imply that E is in eV.\n    k <- 8.62e-5 \n\n    # B0 is the normalization constant.  \n    # E is the activation energy.\n    # T_ref is the standardization temperature (in K).\n    \n    calc <- B0 - E/k * (1/temp - 1/Tref)\n\n    return(calc)\n}\n\n###################### Schoolfield model.\n# A version of the Schoolfield model which ignores \n# the inactivation of the rate-limiting enzyme at \n# low temperature.\nSchoolfield <- function(B0, E, E_D, T_h, temp) {\n    \n    # Boltzmann's constant. Units imply that E and E_D are in eV.\n    k <- 8.62e-5\n\n    # B0 is the normalization constant.    \n    # E is the activation energy.\n    # E_D is the de-activation energy.    \n    # T_h is the temperature at which the rate-limiting enzyme \n    # is 50% active and 50% denatured due to high temperature.\n    \n   #     return(B0 - E/k * (1/temp - 1/Tref) - log(1 + exp((E_D/k) * (1/T_h - 1/temp)))) #Schoolfied model in original form (not with T_pk as an explicit parameter)\n\n    return(B0 + log(exp((-E/k) * ((1/temp) - (1/Tref)))/(1 + (E/(E_D - E)) * exp(E_D/k * (1/T_h - 1/temp))))) ## T_pk as an explicit parameter. FITS BETTER\n   \n}\n\n\n    ############################\n    # M  A  I  N    C  O  D  E #\n    ############################\n\nTPCFit <- function(Data,PLOT=TRUE,OverPLOT=FALSE,Model=\"Schoolfield\"){ # MODEL can be also \"Boltzmann\" or \"all\" for both\n\n    if (OverPLOT==TRUE) PLOT <- FALSE\n\n\n    # Loads Data\n    curvespt <- Data\n    curvespt$OriginalTraitValue <- as.numeric(curvespt$OriginalTraitValue)\n\n    # Transform temperatures to Kelvin and log-transform the\n    # trait values.\n    curvespt$K <- curvespt$ConTemp + 273.15\n\n\n    ###################################################################\n    # Create unique species/individual IDs, with a series of vectors. #\n    ###################################################################\n\n    # Initialize the current ID at 0. You'll see why later...\n    current_ID <- 0\n\n    # Initialize an empty vector of species IDs (as a number).\n    id <- c()\n\n    # Initialize an empty vector of species names.\n    id_spp <- c()\n\n    # Initialize an empty vector of processes (e.g., photosynthesis, respiration).\n    id_process <- c()\n\n    # Read each row of the data frame.\n    for (k in 1:nrow(curvespt))\n        {\n\n    # If the ID of this row is different from the current ID...\n    if ( current_ID != curvespt$FinalID[k])\n\t{\n    \n    # Change the current ID to the one found in this row.\n    current_ID <- curvespt$FinalID[k]\n    \n    # Add information for this species to the 3 vectors \n    # that we initialized above.\n    id <- c(id, current_ID)\n    id_spp <- c(id_spp, curvespt$Consumer[k])\n    id_process <- c(id_process, curvespt$StandardisedTraitName[k])\n}\n}\n\n    # Initialize empty vectors to store the parameter estimates\n    # that will be obtained.\n\n    if (Model==\"Boltzmann\" | Model==\"all\")\n        {\n    E_boltz <- c()\n    B0_boltz <- c()\n    T_pk_boltz <- c()\n    P_pk_boltz <- c()\n    AIC_boltz <- c()\n    r_sq_boltz <- c()\n}\n\n    if (Model==\"Schoolfield\" | Model==\"all\")\n        {\n    B0_sch <- c()\n    E_sch <- c()\n    E_D_sch <- c()\t\n    T_h_sch <- c()\n    T_pk_sch <- c()\n    P_pk_sch <- c()\n    AIC_sch <- c()\n    r_sq_sch <- c()\n}\n\n    if (Model==\"all\"){\n        selected_model<- c()}\n\n    P_pkBug <- c()\n    B0Bug <- c()\n    AftPk <-c()\n    BefPk <- c()\n\n\n    # Go through every single species ID and try to fit the the selected models.\n    for(i in 1:length(id)) \n        { \n\n    # Get only the part of the data that correspond to that particular ID.\n    current_dataset <- curvespt[curvespt$FinalID == id[i],]\n\n    ## If there are negative values, substract the minimum value\n    MinVal <- NA\n    if (min(current_dataset$OriginalTraitValue)<=0){\n        MinVal <- min(current_dataset$OriginalTraitValue)\n        current_dataset$OriginalTraitValue <-current_dataset$OriginalTraitValue - MinVal\n        current_dataset <-current_dataset[-which(current_dataset$OriginalTraitValue==0),]}\n\n    ## Calculates number of data points after and before the Tpk\n    Max <- which.max(current_dataset$OriginalTraitValue)\n    AftPk <- c(AftPk,(length(current_dataset$OriginalTraitValue)-Max))\n    BefPk <- c(BefPk,(Max-1))\n    \n    # Runs only if we have at least 5 data points and more than one temperature\n    if (length(current_dataset$OriginalTraitValue)>=5 && length(unique(current_dataset$K))>1)\n        {\n\n    # Estimate T.h as being approximately T.peak.\n    T.h.st  <- GetTpk(tmp=current_dataset$K, rate=current_dataset$OriginalTraitValue)\n    E.st    <- GetE(tmp=current_dataset$K, rate=current_dataset$OriginalTraitValue, T.p=T.h.st)\n    B.st <- GetB0(tmp=current_dataset$K, rate=current_dataset$OriginalTraitValue)\n\n\n    if (Model==\"Boltzmann\" | Model==\"all\"){\n        ###############################\n        # Boltzmann - Arrhenius model #\n        ###############################\n        \n        # Initialize the fitting variable to NA (empty).\n        boltzmann_nls <- NA\n\n        \n        # Try and fit the model.\n        try( \n            boltzmann_nls <- nlsLM(\n                log(OriginalTraitValue) ~ Boltzmann.Arrhenius(B0, E, temp = K),\n                start = c(B0 = B.st, E = E.st),\n                lower=c(B0=-Inf, E=0),\n                upper=c(B0=Inf,  E=Inf),\n                control=list(minFactor=1 / 2^16, maxiter=1e4),\n                data = current_dataset, \n                na.action=na.omit),\n            silent=TRUE\n            )\n        \n        # If fitting worked ...\n        if(!is.na(boltzmann_nls[1])) \n            { \n\n    # Collect the parameter estimates...\n    if (!is.na(MinVal)){ ## Add MinVal if it was substracted\n        B0_boltz <- c(B0_boltz, (coef(boltzmann_nls)[\"B0\"]+MinVal))\n        if (Model==\"Boltzmann\") B0Bug <- c(B0Bug,TRUE) ## When both models are fit, B0Bug is attached in Schoolfield\n    }else {\n         B0_boltz <- c(B0_boltz, coef(boltzmann_nls)[\"B0\"])\n         if (Model==\"Boltzmann\") B0Bug <- c(B0Bug,FALSE)\n     }\n    E_boltz <- c(E_boltz, coef(boltzmann_nls)[\"E\"])\n    AIC_boltz<- c(AIC_boltz, AIC(boltzmann_nls))\n\n    # Calculate the R squared value as: 1 - (rss/tss)\n    rss <- sum((exp(predict(boltzmann_nls)) - \n                    current_dataset$OriginalTraitValue)^2, \n               na.rm = TRUE)\n    tss <- sum(\n        (current_dataset$OriginalTraitValue - \n             mean(current_dataset$OriginalTraitValue, na.rm = TRUE))^2, \n        na.rm = TRUE)\n    \n    if ( tss != 0 )\n        {\n    r_sq_boltz <- c(r_sq_boltz, 1 - (rss/tss))\n} else\n    {\n    r_sq_boltz <- c(r_sq_boltz, 1)\n}\n    \n    # Calculate the peak of the curve and its \n    # corresponding temperature value.\n    curr_prediction <- predict(boltzmann_nls)\n    for (j in 1:length(curr_prediction))\n        {\n    \n    # If we found the maximum performance, exit the loop.\n    if (curr_prediction[j] == max(curr_prediction))\n        {\n    break\n}\n}\n    \n    T_pk_boltz <- c(T_pk_boltz, current_dataset$K[j])\n    if (!is.na(MinVal)){ ## Add MinVal if it was substracted\n        P_pk_boltz <- c(P_pk_boltz, (curr_prediction[j]+MinVal))\n        if (Model==\"Boltzmann\") P_pkBug <- c(P_pkBug,TRUE) ## When both models are fit, PpkBug is attached in Schoolfield\n\n    }else {\n         P_pk_boltz <- c(P_pk_boltz, curr_prediction[j])\n         if (Model==\"Boltzmann\") P_pkBug <- c(P_pkBug,FALSE)\n     }\n\n\n    #######################################\n    # Plotting Boltzmann - Arrhenius' fit #\n    #######################################\n    \n    # Create a name for the output file using:\n    #\t- the original id number\n    #   - the species name\n    #   - the model\n    output_name <- paste(\n        current_dataset$FinalID[1], \n        current_dataset$Consumer[1], \n        'Boltzmann_Arrhenius',\n        sep = \"_\"\n        )\n    \n    # Remove any characters that won't look good in a file name,\n    # using a regular expression.\n    output_name <- gsub(\"[^\\\\w|\\\\s](|)\", \"\", output_name, perl=TRUE)\n    \n    # Convert spaces to underscores.\n    output_name <- gsub(\"\\\\s+\", \"_\", output_name, perl=TRUE)\n    \n    # CHANGE THIS to set an alternative output directory.\n    outdir <- \"./\"\n    \n    # Generate predictions from the model fit...\n    tmp_temps <- seq(min(\n        floor(current_dataset$K)), \n                     ceiling(max(current_dataset$K)\n                             ), length = 200)\n    \n    tmp_model <- exp(Boltzmann.Arrhenius(\n        coef(boltzmann_nls)[\"B0\"],\n        coef(boltzmann_nls)[\"E\"],\n        tmp_temps\n        ))\n    \n    ModelToPlotB <- data.frame(\n        Temperature = tmp_temps - 273.15, \n        TraitValue = tmp_model\n        )\n    \n    # Prepare the data points of the original values.\n    DataToPlot <- data.frame(\n        Temperature = current_dataset$K - 273.15, \n        TraitValue = current_dataset$OriginalTraitValue\n        )\n    DataToPlot <- na.omit(DataToPlot)\n\n    #### If we want individual plots\n    if (PLOT==TRUE) {\n        # Plot!\n        p <- ggplot() + geom_point(data = DataToPlot, aes(x = Temperature, \n                                       y = TraitValue), size = 3, col = \"black\", bg = \"lightcyan2\", \n                                   alpha = 0.7, pch = 21) + \n            geom_line(data = ModelToPlotB, \n                      aes(x = Temperature, y = TraitValue), colour = \"#1b9e77\", \n                      lwd = 1.3) +\n                \n                ggtitle(paste(current_dataset$Consumer[1])) +\n                    xlab(expression(paste(\"Temperature (\", degree, C, \")\"))) + \n                        ylab(current_dataset$StandardisedTraitName[1]) +\n                            theme_bw() + theme(plot.title = element_text(size = 12), \n                                               axis.title = element_text(size = 10)) +\n                                annotate(\"text\", size = 3, label=             \n                                             paste(\"R^2 boltz=\", sprintf(\"%.2f\", r_sq_boltz[i]), \"\\nE boltz=\", format(coef(boltzmann_nls)[\"E\"], digits = 3),\"\\nAIC boltz=\",format(AIC(boltzmann_nls),digits=3)), \n                                         x = min(DataToPlot[, \"Temperature\"]),\n                                         y = mean(DataToPlot[, \"TraitValue\"]),\n                                         hjust=0,\n                                         fontface = 3)\n        \n        # Save it as an svg file.\n        svg_file <- paste(outdir, gsub(\"/|#\", \"\", output_name), \".svg\", sep=\"\")\n            ggsave(filename = svg_file, plot = p, height = 4, width = 4.2)\n    }\n    \n    \n} else # If fitting failed ...\n    {\n    # Populate the vectors with missing values.\n    E_boltz <- c(E_boltz, NA)\n    B0_boltz <- c(B0_boltz, NA)\n    T_pk_boltz <- c(T_pk_boltz, NA)\n    P_pk_boltz <- c(P_pk_boltz, NA)\n    AIC_boltz <- c(AIC_boltz, NA)\n    r_sq_boltz <- c(r_sq_boltz, NA)\n    if (Model==\"Boltzmann\") { ## When both models are fit, this is attached in Schoolfield\n        B0Bug <- c(B0Bug,NA)\n        P_pkBug <- c(P_pkBug,NA)}\n}\n    }  else # If there are not enough values\n        {\n    # Populate the vectors with missing values.\n    E_boltz <- c(E_boltz, NA)\n    B0_boltz <- c(B0_boltz, NA)\t\n    T_pk_boltz <- c(T_pk_boltz, NA)\n    P_pk_boltz <- c(P_pk_boltz, NA)\n    AIC_boltz <- c(AIC_boltz, NA)\n    r_sq_boltz <- c(r_sq_boltz, NA)\n    if (Model==\"Boltzmann\") { ## When both models are fit, this is attached in Schoolfield\n        B0Bug <- c(B0Bug,NA)\n        P_pkBug <- c(P_pkBug,NA)}\n}     \n\n}\n\n    if (Model==\"Schoolfield\" | Model==\"all\"){\n        \n    #####################\n    # Schoolfield model #\n    #####################\n\n    # Checks if all values are NA and we have more than one different temperature value\n    if (length(current_dataset$OriginalTraitValue)>=5 && length(unique(current_dataset$K))>1)\n        {\n\n    schoolfield_nls <- NA\n    try( \n        schoolfield_nls <- nlsLM(\n            log(OriginalTraitValue) ~ Schoolfield(B0, E, E_D, T_h, temp = K), \n            start=c(B0 = B.st, E = E.st, E_D = 4*E.st, T_h=T.h.st),\n            lower=c(B0=-Inf,   E=0,    E.D=0, Th=0),\n            upper=c(B0=Inf,    E=Inf,  E.D=Inf, Th=273.15+150),\n            data=current_dataset, control=list(minFactor=1 / 2^16, maxiter=1024)),\n        silent=TRUE)\n    \n    \n    # If fitting worked ...\n    if(!is.na(schoolfield_nls[1])) \n\t{ \n\n    # Collect the parameter estimates..\n    if (!is.na(MinVal)){ ## Add MinVal if it was substracted\n        B0Bug <- c(B0Bug,TRUE)\n        B0_sch <- c(B0_sch, (coef(schoolfield_nls)[\"B0\"]+MinVal))\n    }else {\n         B0Bug <- c(B0Bug,FALSE)\n         B0_sch <- c(B0_sch, coef(schoolfield_nls)[\"B0\"])\n     }\n    E_sch <- c(E_sch, coef(schoolfield_nls)[\"E\"])\n    E_D_sch <- c(E_D_sch, coef(schoolfield_nls)[\"E_D\"])\n    T_h_sch <- c(T_h_sch, coef(schoolfield_nls)[\"T_h\"])\n    AIC_sch<- c(AIC_sch, AIC(schoolfield_nls))\n    \n    # Calculate the R squared value as: 1 - (rss/tss)\n    rss <- sum((exp(predict(schoolfield_nls)) - \n                    current_dataset$OriginalTraitValue)^2, \n               na.rm = TRUE)\n    tss <- sum(\n        (current_dataset$OriginalTraitValue - \n             mean(current_dataset$OriginalTraitValue, na.rm = TRUE))^2, \n        na.rm = TRUE)\n    \n    if ( tss != 0 )\n        {\n    r_sq_sch <- c(r_sq_sch, 1 - (rss/tss))\n} else\n    {\n    r_sq_sch <- c(r_sq_sch, 1)\n}\n    \n    # Calculate the peak of the curve and its \n    # corresponding temperature value.\n    curr_prediction <- predict(schoolfield_nls)\n    for (j in 1:length(curr_prediction))\n        {\n    # If we found the maximum performance, exit the loop.\n    if (curr_prediction[j] == max(curr_prediction))\n        {\n    break\n}\n}\n    \n    T_pk_sch <- c(T_pk_sch, current_dataset$K[j])\n    if (!is.na(MinVal)){ ## Add MinVal if it was substracted\n        P_pkBug <- c(P_pkBug,TRUE)\n        P_pk_sch <- c(P_pk_sch, (curr_prediction[j]+MinVal))\n    }else {\n         P_pkBug <- c(P_pkBug,FALSE)\n         P_pk_sch <- c(P_pk_sch, curr_prediction[j])\n     }\n    \n\n\n    ##############################\n    # Plotting Schoolfield's fit #\n    ##############################\n    \n    # Create a name for the output file using:\n    #\t- the original id number\n    #   - the species name\n    #   - the model\n    output_name <- paste(\n        current_dataset$FinalID[1], \n        current_dataset$Consumer[1], \n        'Schoolfield',\n        sep = \"_\"\n        )\n    \n    \n    # Remove any characters that won't look good in a file name,\n    # using a regular expression.\n    output_name <- gsub(\"[^\\\\w|\\\\s](|)\", \"\", output_name, perl=TRUE)\n    \n    # Convert spaces to underscores.\n    output_name <- gsub(\"\\\\s+\", \"_\", output_name, perl=TRUE)\n    \n    # CHANGE THIS to set an alternative output directory.\n    outdir <- \"./\"\n    \n    # Generate predictions from the model fit...\n    tmp_temps <- seq(min(\n        floor(current_dataset$K)), \n                     ceiling(max(current_dataset$K)\n                             ), length = 200)\n    \n    tmp_model <- exp(Schoolfield(\n        coef(schoolfield_nls)[\"B0\"],\n        coef(schoolfield_nls)[\"E\"],\n        coef(schoolfield_nls)[\"E_D\"],\n        coef(schoolfield_nls)[\"T_h\"],\n        tmp_temps\n        ))\n    \n    ModelToPlotS <- data.frame(\n        Temperature = tmp_temps - 273.15, \n        TraitValue = tmp_model\n        )\n    \n    # Prepare the data points of the original values.\n    DataToPlot <- data.frame(\n        Temperature = current_dataset$K - 273.15, \n        TraitValue = current_dataset$OriginalTraitValue\n        )\n    DataToPlot <- na.omit(DataToPlot)\n\n    #### If we want individual plots\n    if (PLOT==TRUE) {\n        # Plot!\n        p <- ggplot() + geom_point(data = DataToPlot, aes(x = Temperature, \n                                       y = TraitValue), size = 3, col = \"black\", bg = \"lightcyan2\", \n                                   alpha = 0.7, pch = 21) + \n            geom_line(data = ModelToPlotS, \n                      aes(x = Temperature, y = TraitValue), colour = \"#1b9e77\", \n                      lwd = 1.3) +                           \n                ggtitle(paste(current_dataset$Consumer[1])) +\n                    xlab(expression(paste(\"Temperature (\", degree, C, \")\"))) + \n                        ylab(current_dataset$StandardisedTraitName[1]) +\n                            theme_bw() + theme(plot.title = element_text(size = 12), \n                                               axis.title = element_text(size = 10)) +\n                                annotate(\"text\", size = 3, label=             \n                                             paste(\"R^2\",\"sch=\", sprintf(\"%.2f\", r_sq_sch[i]),\"\\nE sch=\", format(coef(schoolfield_nls)[\"E\"], digits = 3),\"\\nAIC sch=\",format(AIC(schoolfield_nls),digits=3)), \n                                         x = min(DataToPlot[, \"Temperature\"]),\n                                         y = mean(DataToPlot[, \"TraitValue\"]),\n                                         hjust=0,\n                                         fontface = 3)\n        \n        # Save it as an svg file.\n        svg_file <- paste(outdir, gsub(\"/|#\", \"\", output_name), \".svg\", sep=\"\")\n            ggsave(filename = svg_file, plot = p, height = 4, width = 4.2)\n\n    }\n} else # If fitting failed ...\n    {\n    # Populate the vectors with missing values.\n    B0_sch <- c(B0_sch, NA)\n    B0Bug <- c(B0Bug,NA)\n    E_sch <- c(E_sch, NA)\n    E_D_sch <- c(E_D_sch, NA)\t\n    T_h_sch <- c(T_h_sch, NA)\n    T_pk_sch <- c(T_pk_sch, NA)\n    P_pk_sch <- c(P_pk_sch, NA)\n    P_pkBug <- c(P_pkBug,NA)\n    AIC_sch <- c(AIC_sch, NA)\n    r_sq_sch <- c(r_sq_sch, NA)\n}\n} else # If there are not enough values\n    {\n    # Populate the vectors with missing values.\n    B0_sch <- c(B0_sch, NA)\n    B0Bug <- c(B0Bug,NA)\n    E_sch <- c(E_sch, NA)\n    E_D_sch <- c(E_D_sch, NA)\t\n    T_h_sch <- c(T_h_sch, NA)\n    T_pk_sch <- c(T_pk_sch, NA)\n    P_pk_sch <- c(P_pk_sch, NA)\n    P_pkBug <- c(P_pkBug,NA)\n    AIC_sch <- c(AIC_sch, NA)\n    r_sq_sch <- c(r_sq_sch, NA)\n}    \n}\n\n    if (Model==\"all\")\n        {\n\n    if (OverPLOT==TRUE) { ## In case we want both models in the same figure with the overlaid fits.\n        ##############################\n        # Plotting both fits #\n        ##############################\n        \n        # Create a name for the output file using:\n        #\t- the original id number\n        #   - the species name\n        #   - the model\n        output_name <- paste(\n            current_dataset$FinalID[1], \n            current_dataset$Consumer[1], \n            'Schoolfield_Boltz',\n            sep = \"_\"\n            )\n        \n        \n        # Remove any characters that won't look good in a file name,\n        # using a regular expression.\n        output_name <- gsub(\"[^\\\\w|\\\\s](|)\", \"\", output_name, perl=TRUE)\n        \n        # Convert spaces to underscores.\n        output_name <- gsub(\"\\\\s+\", \"_\", output_name, perl=TRUE)\n        \n        # CHANGE THIS to set an alternative output directory.\n        outdir <- \"./\"\n        \n        \n        # Prepare the data points of the original values.\n        DataToPlot <- data.frame(\n            Temperature = current_dataset$K - 273.15, \n            TraitValue = current_dataset$OriginalTraitValue\n            )\n        DataToPlot <- na.omit(DataToPlot)\n\n        ## Trait Units for plot\n        Unit <- current_dataset$StandardisedTraitUnit[1]\n        if (is.na(Unit)) Unit <- current_dataset$OriginalTraitUnit[1]\n        \n        # Plot!\n        p <- ggplot() + geom_point(data = DataToPlot, aes(x = Temperature, \n                                       y = TraitValue), size = 3, col = \"black\", bg = \"lightcyan2\", \n                                   alpha = 0.7, pch = 21) + \n            geom_line(data = ModelToPlotB, \n                      aes(x = Temperature, y = TraitValue), colour = \"#1b9e77\", \n                      lwd = 1.3) +            \n                geom_line(data = ModelToPlotS, \n                          aes(x = Temperature, y = TraitValue), colour = \"red\", \n                          lwd = 1.3) +             \n                    ggtitle(paste(current_dataset$Consumer[1])) +\n                        xlab(expression(paste(\"Temperature (\", degree, C, \")\"))) + \n                            ylab(paste(current_dataset$StandardisedTraitName[1],\"\\n\",Unit)) +\n                                theme_bw() + theme(plot.title = element_text(size = 12), \n                                                   axis.title = element_text(size = 10)) +\n                                    annotate(\"text\", size = 3, label=             \n                                                 paste(\"R^2\",\"sch=\", sprintf(\"%.2f\", r_sq_sch[i]),\"\\nE sch=\", format(coef(schoolfield_nls)[\"E\"], digits = 3),\"\\nAIC sch=\",format(AIC(schoolfield_nls),digits=3),\"\\nR^2 boltz=\", sprintf(\"%.2f\", r_sq_boltz[i]), \"\\nE boltz=\", format(coef(boltzmann_nls)[\"E\"], digits = 3),\"\\nAIC boltz=\",format(AIC(boltzmann_nls),digits=3)), \n                                             x = min(DataToPlot[, \"Temperature\"]),\n                                             y = mean(DataToPlot[, \"TraitValue\"]),\n                                             hjust=0,\n                                             fontface = 3)\n        \n        # Save it as an svg file.\n        svg_file <- paste(outdir, gsub(\"/|#\", \"\", output_name), \".svg\", sep=\"\")\n            ggsave(filename = svg_file, plot = p, height = 4, width = 4.2)\n\n    }     \n\n    ##################################################################\n    # Compare the two models using the Akaike Information Criterion. #\n    ##################################################################\n    \n    # If both models failed to fit, add NA. \n    if (is.na(AIC_sch[i]) && is.na(AIC_boltz[i]))\n\t{\n    selected_model <- c(selected_model, NA)\n    \n    # If only one of the two models could be fit, that is \n    # automatically the winner!\n} else if (is.na(AIC_sch[i]) && !is.na(AIC_boltz[i]))\n      {\n    selected_model <- c(selected_model, 'boltzmann')\n} else if (is.na(AIC_boltz[i]) && !is.na(AIC_sch[i]))\n      {\n    selected_model<- c(selected_model, \"schoolfield\")\t\n    \n    # If both models were able to fit and Schoolfield's AIC\n    # was lower, then that is the better model for this curve.\n} else if (AIC_sch[i] < AIC_boltz[i])\n      {\n    selected_model<- c(selected_model,  \"schoolfield\")\n    \n    # And the opposite for the Boltzmann - Arrhenius model.\n} else\n    {\n    selected_model<- c(selected_model,  \"boltzmann\")\n}\n}\n}\n\n\n    ##################################################################\n    # RESULTS FILE #\n    ##################################################################\n  \n\n    if (Model==\"all\"){\n        # Compile all data into a data frame.\n        results <- data.frame(\n            id, id_spp, id_process,E_boltz, E_sch, B0_boltz, B0_sch, B0Bug, E_D_sch, \n            T_h_sch, T_pk_boltz, T_pk_sch, P_pk_boltz, P_pk_sch, P_pkBug,AIC_boltz, \n            AIC_sch, r_sq_boltz, r_sq_sch, AftPk,BefPk,selected_model\n            )}\n\n    if (Model==\"Schoolfield\"){\n        results <- data.frame(\n            id, id_spp, id_process,E_sch, B0_sch, B0Bug, E_D_sch, \n            T_h_sch,  T_pk_sch, P_pk_sch, P_pkBug,\n            AIC_sch,  r_sq_sch, AftPk,BefPk)}\n\n    if (Model==\"Boltzmann\"){\n        results <- data.frame(\n            id, id_spp, id_process,E_boltz, B0_boltz, B0Bug,\n            T_pk_boltz, P_pk_boltz, P_pkBug,\n            AIC_boltz,  r_sq_boltz, AftPk,BefPk    )}\n\n\n    # Write the results as a CSV file.\n    write.csv(results, file = \"results.csv\", row.names = FALSE)\n\n    return()\n}\n\n",
    "created" : 1479267423103.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2401056247",
    "id" : "32E10EC8",
    "lastKnownWriteTime" : 1468947687,
    "last_content_update" : 1468947687,
    "path" : "~/Downloads/TPCFitting.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}